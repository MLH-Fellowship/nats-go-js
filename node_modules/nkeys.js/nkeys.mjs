function validateBase64(s) {
    if (!/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s)) {
        throw new TypeError('invalid base64 string');
    }
}
function validateHex(s) {
    if (!/^(?:[A-Fa-f0-9]{2})+$/.test(s)) {
        throw new TypeError('invalid hex string');
    }
}
function getLengths(b64) {
    const len = b64.length;
    let validLen = b64.indexOf("=");
    if (validLen === -1) {
        validLen = len;
    }
    const placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
function init(lookup, revLookup, urlsafe = false) {
    function _byteLength(validLen, placeHoldersLen) {
        return Math.floor((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);
    }
    function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(buf, start, end) {
        const out = new Array((end - start) / 3);
        for(let i = start, curTriplet = 0; i < end; i += 3){
            out[curTriplet++] = tripletToBase64((buf[i] << 16) + (buf[i + 1] << 8) + buf[i + 2]);
        }
        return out.join("");
    }
    return {
        byteLength (b64) {
            return _byteLength.apply(null, getLengths(b64));
        },
        toUint8Array (b64) {
            const [validLen, placeHoldersLen] = getLengths(b64);
            const buf = new Uint8Array(_byteLength(validLen, placeHoldersLen));
            const len = placeHoldersLen ? validLen - 4 : validLen;
            let tmp;
            let curByte = 0;
            let i;
            for(i = 0; i < len; i += 4){
                tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
                buf[curByte++] = tmp >> 16 & 255;
                buf[curByte++] = tmp >> 8 & 255;
                buf[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
                buf[curByte++] = tmp & 255;
            } else if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
                buf[curByte++] = tmp >> 8 & 255;
                buf[curByte++] = tmp & 255;
            }
            return buf;
        },
        fromUint8Array (buf) {
            const maxChunkLength = 16383;
            const len = buf.length;
            const extraBytes = len % 3;
            const len2 = len - extraBytes;
            const parts = new Array(Math.ceil(len2 / 16383) + (extraBytes ? 1 : 0));
            let curChunk = 0;
            let chunkEnd;
            for(let i = 0; i < len2; i += 16383){
                chunkEnd = i + 16383;
                parts[curChunk++] = encodeChunk(buf, i, chunkEnd > len2 ? len2 : chunkEnd);
            }
            let tmp;
            if (extraBytes === 1) {
                tmp = buf[len2];
                parts[curChunk] = lookup[tmp >> 2] + lookup[tmp << 4 & 63];
                if (!urlsafe) parts[curChunk] += "==";
            } else if (extraBytes === 2) {
                tmp = buf[len2] << 8 | buf[len2 + 1] & 255;
                parts[curChunk] = lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63];
                if (!urlsafe) parts[curChunk] += "=";
            }
            return parts.join("");
        }
    };
}
const lookup = [];
const revLookup = [];
const code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(let i = 0, l = code.length; i < l; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
const { byteLength , toUint8Array , fromUint8Array  } = init(lookup, revLookup);
const hextable = new TextEncoder().encode("0123456789abcdef");
function errInvalidByte(byte) {
    return new Error("encoding/hex: invalid byte: " + new TextDecoder().decode(new Uint8Array([
        byte
    ])));
}
function errLength() {
    return new Error("encoding/hex: odd length hex string");
}
function fromHexChar(byte) {
    switch(true){
        case 48 <= byte && byte <= 57:
            return [
                byte - 48,
                true
            ];
        case 97 <= byte && byte <= 102:
            return [
                byte - 97 + 10,
                true
            ];
        case 65 <= byte && byte <= 70:
            return [
                byte - 65 + 10,
                true
            ];
    }
    return [
        0,
        false
    ];
}
function encodedLen(n) {
    return n * 2;
}
function encode3(dst, src) {
    const srcLength = encodedLen(src.length);
    if (dst.length !== srcLength) {
        throw new Error("Out of index.");
    }
    for(let i1 = 0; i1 < src.length; i1++){
        const v = src[i1];
        dst[i1 * 2] = hextable[v >> 4];
        dst[i1 * 2 + 1] = hextable[v & 15];
    }
    return srcLength;
}
function encodeToString(src) {
    const dest = new Uint8Array(encodedLen(src.length));
    encode3(dest, src);
    return new TextDecoder().decode(dest);
}
function decode3(dst, src) {
    let i1 = 0;
    for(; i1 < Math.floor(src.length / 2); i1++){
        const [a, aOK] = fromHexChar(src[i1 * 2]);
        if (!aOK) {
            return [
                i1,
                errInvalidByte(src[i1 * 2])
            ];
        }
        const [b, bOK] = fromHexChar(src[i1 * 2 + 1]);
        if (!bOK) {
            return [
                i1,
                errInvalidByte(src[i1 * 2 + 1])
            ];
        }
        dst[i1] = a << 4 | b;
    }
    if (src.length % 2 == 1) {
        const [, ok] = fromHexChar(src[i1 * 2]);
        if (!ok) {
            return [
                i1,
                errInvalidByte(src[i1 * 2])
            ];
        }
        return [
            i1,
            errLength()
        ];
    }
    return [
        i1,
        undefined
    ];
}
function decodeString(s) {
    const src = new TextEncoder().encode(s);
    const [n, err] = decode3(src, src);
    if (err) {
        throw err;
    }
    return src.slice(0, n);
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
var BoxLength;
function vn(x, xi, y, yi, n) {
    let i1, d = 0;
    for(i1 = 0; i1 < n; i1++)d |= x[xi + i1] ^ y[yi + i1];
    return (1 & d - 1 >>> 8) - 1;
}
function _verify_16(x, xi, y, yi) {
    return vn(x, xi, y, yi, 16);
}
function _verify_32(x, xi, y, yi) {
    return vn(x, xi, y, yi, 32);
}
var ScalarLength;
(function(ScalarLength1) {
    ScalarLength1[ScalarLength1["Scalar"] = 32] = "Scalar";
    ScalarLength1[ScalarLength1["GroupElement"] = 32] = "GroupElement";
})(ScalarLength || (ScalarLength = {
}));
function _salsa20(o, p, k, c) {
    const j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
    let x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
    for(let i1 = 0; i1 < 20; i1 += 2){
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
    }
    x0 = x0 + j0 | 0;
    x1 = x1 + j1 | 0;
    x2 = x2 + j2 | 0;
    x3 = x3 + j3 | 0;
    x4 = x4 + j4 | 0;
    x5 = x5 + j5 | 0;
    x6 = x6 + j6 | 0;
    x7 = x7 + j7 | 0;
    x8 = x8 + j8 | 0;
    x9 = x9 + j9 | 0;
    x10 = x10 + j10 | 0;
    x11 = x11 + j11 | 0;
    x12 = x12 + j12 | 0;
    x13 = x13 + j13 | 0;
    x14 = x14 + j14 | 0;
    x15 = x15 + j15 | 0;
    o[0] = x0 >>> 0 & 255;
    o[1] = x0 >>> 8 & 255;
    o[2] = x0 >>> 16 & 255;
    o[3] = x0 >>> 24 & 255;
    o[4] = x1 >>> 0 & 255;
    o[5] = x1 >>> 8 & 255;
    o[6] = x1 >>> 16 & 255;
    o[7] = x1 >>> 24 & 255;
    o[8] = x2 >>> 0 & 255;
    o[9] = x2 >>> 8 & 255;
    o[10] = x2 >>> 16 & 255;
    o[11] = x2 >>> 24 & 255;
    o[12] = x3 >>> 0 & 255;
    o[13] = x3 >>> 8 & 255;
    o[14] = x3 >>> 16 & 255;
    o[15] = x3 >>> 24 & 255;
    o[16] = x4 >>> 0 & 255;
    o[17] = x4 >>> 8 & 255;
    o[18] = x4 >>> 16 & 255;
    o[19] = x4 >>> 24 & 255;
    o[20] = x5 >>> 0 & 255;
    o[21] = x5 >>> 8 & 255;
    o[22] = x5 >>> 16 & 255;
    o[23] = x5 >>> 24 & 255;
    o[24] = x6 >>> 0 & 255;
    o[25] = x6 >>> 8 & 255;
    o[26] = x6 >>> 16 & 255;
    o[27] = x6 >>> 24 & 255;
    o[28] = x7 >>> 0 & 255;
    o[29] = x7 >>> 8 & 255;
    o[30] = x7 >>> 16 & 255;
    o[31] = x7 >>> 24 & 255;
    o[32] = x8 >>> 0 & 255;
    o[33] = x8 >>> 8 & 255;
    o[34] = x8 >>> 16 & 255;
    o[35] = x8 >>> 24 & 255;
    o[36] = x9 >>> 0 & 255;
    o[37] = x9 >>> 8 & 255;
    o[38] = x9 >>> 16 & 255;
    o[39] = x9 >>> 24 & 255;
    o[40] = x10 >>> 0 & 255;
    o[41] = x10 >>> 8 & 255;
    o[42] = x10 >>> 16 & 255;
    o[43] = x10 >>> 24 & 255;
    o[44] = x11 >>> 0 & 255;
    o[45] = x11 >>> 8 & 255;
    o[46] = x11 >>> 16 & 255;
    o[47] = x11 >>> 24 & 255;
    o[48] = x12 >>> 0 & 255;
    o[49] = x12 >>> 8 & 255;
    o[50] = x12 >>> 16 & 255;
    o[51] = x12 >>> 24 & 255;
    o[52] = x13 >>> 0 & 255;
    o[53] = x13 >>> 8 & 255;
    o[54] = x13 >>> 16 & 255;
    o[55] = x13 >>> 24 & 255;
    o[56] = x14 >>> 0 & 255;
    o[57] = x14 >>> 8 & 255;
    o[58] = x14 >>> 16 & 255;
    o[59] = x14 >>> 24 & 255;
    o[60] = x15 >>> 0 & 255;
    o[61] = x15 >>> 8 & 255;
    o[62] = x15 >>> 16 & 255;
    o[63] = x15 >>> 24 & 255;
}
function _hsalsa20(o, p, k, c) {
    const j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
    let x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
    for(let i1 = 0; i1 < 20; i1 += 2){
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
    }
    o[0] = x0 >>> 0 & 255;
    o[1] = x0 >>> 8 & 255;
    o[2] = x0 >>> 16 & 255;
    o[3] = x0 >>> 24 & 255;
    o[4] = x5 >>> 0 & 255;
    o[5] = x5 >>> 8 & 255;
    o[6] = x5 >>> 16 & 255;
    o[7] = x5 >>> 24 & 255;
    o[8] = x10 >>> 0 & 255;
    o[9] = x10 >>> 8 & 255;
    o[10] = x10 >>> 16 & 255;
    o[11] = x10 >>> 24 & 255;
    o[12] = x15 >>> 0 & 255;
    o[13] = x15 >>> 8 & 255;
    o[14] = x15 >>> 16 & 255;
    o[15] = x15 >>> 24 & 255;
    o[16] = x6 >>> 0 & 255;
    o[17] = x6 >>> 8 & 255;
    o[18] = x6 >>> 16 & 255;
    o[19] = x6 >>> 24 & 255;
    o[20] = x7 >>> 0 & 255;
    o[21] = x7 >>> 8 & 255;
    o[22] = x7 >>> 16 & 255;
    o[23] = x7 >>> 24 & 255;
    o[24] = x8 >>> 0 & 255;
    o[25] = x8 >>> 8 & 255;
    o[26] = x8 >>> 16 & 255;
    o[27] = x8 >>> 24 & 255;
    o[28] = x9 >>> 0 & 255;
    o[29] = x9 >>> 8 & 255;
    o[30] = x9 >>> 16 & 255;
    o[31] = x9 >>> 24 & 255;
}
function poly1305_blocks(self, m, mpos, bytes) {
    const hibit = self.fin ? 0 : 1 << 11;
    let t0, t1, t2, t3, t4, t5, t6, t7, c;
    let d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
    const { h , r  } = self;
    let h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3], h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7], h8 = h[8], h9 = h[9];
    const r0 = r[0], r1 = r[1], r2 = r[2], r3 = r[3], r4 = r[4], r5 = r[5], r6 = r[6], r7 = r[7], r8 = r[8], r9 = r[9];
    while(bytes >= 16){
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
    }
    h[0] = h0;
    h[1] = h1;
    h[2] = h2;
    h[3] = h3;
    h[4] = h4;
    h[5] = h5;
    h[6] = h6;
    h[7] = h7;
    h[8] = h8;
    h[9] = h9;
}
function poly1305_update(self, m, mpos, bytes) {
    let i1, want;
    const { buffer  } = self;
    if (self.leftover) {
        want = 16 - self.leftover;
        if (want > bytes) want = bytes;
        for(i1 = 0; i1 < want; i1++)buffer[self.leftover + i1] = m[mpos + i1];
        bytes -= want;
        mpos += want;
        self.leftover += want;
        if (self.leftover < 16) return;
        poly1305_blocks(self, buffer, 0, 16);
        self.leftover = 0;
    }
    if (bytes >= 16) {
        want = bytes - bytes % 16;
        poly1305_blocks(self, m, mpos, want);
        mpos += want;
        bytes -= want;
    }
    if (bytes) {
        for(i1 = 0; i1 < bytes; i1++)buffer[self.leftover + i1] = m[mpos + i1];
        self.leftover += bytes;
    }
}
var SecretBoxLength;
(function(SecretBoxLength1) {
    SecretBoxLength1[SecretBoxLength1["Key"] = 32] = "Key";
    SecretBoxLength1[SecretBoxLength1["Nonce"] = 24] = "Nonce";
    SecretBoxLength1[SecretBoxLength1["Overhead"] = 16] = "Overhead";
    SecretBoxLength1[SecretBoxLength1["Zero"] = 32] = "Zero";
})(SecretBoxLength || (SecretBoxLength = {
}));
function checkLengths(k, n) {
    if (k.length != SecretBoxLength.Key) throw new Error('bad key size');
    if (n.length != SecretBoxLength.Nonce) throw new Error('bad nonce size');
}
function checkArrayTypes(...arrays) {
    for (const array of arrays){
        if (!(array instanceof Uint8Array)) {
            throw new TypeError('unexpected type, use ByteArray');
        }
    }
}
function set25519(r, a) {
    for(let i1 = 0; i1 < 16; i1++)r[i1] = a[i1] | 0;
}
function car25519(o) {
    let i1, v, c = 1;
    for(i1 = 0; i1 < 16; i1++){
        v = o[i1] + c + 65535;
        c = Math.floor(v / 65536);
        o[i1] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    let t, c = ~(b - 1);
    for(let i1 = 0; i1 < 16; i1++){
        t = c & (p[i1] ^ q[i1]);
        p[i1] ^= t;
        q[i1] ^= t;
    }
}
function unpack25519(o, n) {
    for(let i1 = 0; i1 < 16; i1++)o[i1] = n[2 * i1] + (n[2 * i1 + 1] << 8);
    o[15] &= 32767;
}
(function(BoxLength1) {
    BoxLength1[BoxLength1["PublicKey"] = 32] = "PublicKey";
    BoxLength1[BoxLength1["SecretKey"] = 32] = "SecretKey";
    BoxLength1[BoxLength1["SharedKey"] = 32] = "SharedKey";
    BoxLength1[BoxLength1["Nonce"] = SecretBoxLength.Nonce] = "Nonce";
    BoxLength1[BoxLength1["Overhead"] = SecretBoxLength.Overhead] = "Overhead";
})(BoxLength || (BoxLength = {
}));
function checkBoxLengths(pk, sk) {
    if (pk.length != BoxLength.PublicKey) throw new Error('bad public key size');
    if (sk.length != BoxLength.SecretKey) throw new Error('bad secret key size');
}
var HashLength;
(function(HashLength1) {
    HashLength1[HashLength1["Hash"] = 64] = "Hash";
})(HashLength || (HashLength = {
}));
const _K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
];
function _ts64(x, i1, h, l1) {
    x[i1] = h >> 24 & 255;
    x[i1 + 1] = h >> 16 & 255;
    x[i1 + 2] = h >> 8 & 255;
    x[i1 + 3] = h & 255;
    x[i1 + 4] = l1 >> 24 & 255;
    x[i1 + 5] = l1 >> 16 & 255;
    x[i1 + 6] = l1 >> 8 & 255;
    x[i1 + 7] = l1 & 255;
}
var SignLength;
(function(SignLength1) {
    SignLength1[SignLength1["PublicKey"] = 32] = "PublicKey";
    SignLength1[SignLength1["SecretKey"] = 64] = "SecretKey";
    SignLength1[SignLength1["Seed"] = 32] = "Seed";
    SignLength1[SignLength1["Signature"] = 64] = "Signature";
})(SignLength || (SignLength = {
}));
function cswap(p, q, b) {
    for(let i1 = 0; i1 < 4; i1++){
        sel25519(p[i1], q[i1], b);
    }
}
var AuthLength;
(function(AuthLength1) {
    AuthLength1[AuthLength1["Auth"] = 32] = "Auth";
    AuthLength1[AuthLength1["AuthFull"] = 64] = "AuthFull";
    AuthLength1[AuthLength1["Key"] = 32] = "Key";
})(AuthLength || (AuthLength = {
}));
function B2S_GET32(v, i1) {
    return v[i1] ^ v[i1 + 1] << 8 ^ v[i1 + 2] << 16 ^ v[i1 + 3] << 24;
}
function ROTR32(x, y) {
    return x >>> y ^ x << 32 - y;
}
const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
];
function ADD64AA(v, a, b) {
    let o0 = v[a] + v[b], o1 = v[a + 1] + v[b + 1];
    if (o0 >= 4294967296) o1++;
    v[a] = o0;
    v[a + 1] = o1;
}
function ADD64AC(v, a, b0, b1) {
    let o0 = v[a] + b0;
    if (b0 < 0) o0 += 4294967296;
    let o1 = v[a + 1] + b1;
    if (o0 >= 4294967296) o1++;
    v[a] = o0;
    v[a + 1] = o1;
}
function B2B_GET32(arr, i1) {
    return arr[i1] ^ arr[i1 + 1] << 8 ^ arr[i1 + 2] << 16 ^ arr[i1 + 3] << 24;
}
var SealedBoxLength;
(function(SealedBoxLength1) {
    SealedBoxLength1[SealedBoxLength1["PublicKey"] = BoxLength.PublicKey] = "PublicKey";
    SealedBoxLength1[SealedBoxLength1["SecretKey"] = BoxLength.SecretKey] = "SecretKey";
    SealedBoxLength1[SealedBoxLength1["Nonce"] = BoxLength.Nonce] = "Nonce";
    SealedBoxLength1[SealedBoxLength1["Overhead"] = BoxLength.PublicKey + BoxLength.Overhead] = "Overhead";
})(SealedBoxLength || (SealedBoxLength = {
}));
let helper;
function setEd25519Helper(lib) {
    helper = lib;
}
function getEd25519Helper() {
    return helper;
}
function encode1(bytes) {
    return btoa(String.fromCharCode(...bytes));
}
const encode2 = encode1;
function decode1(b64str) {
    const bin = atob(b64str);
    const bytes = new Uint8Array(bin.length);
    for(let i1 = 0; i1 < bin.length; i1++){
        bytes[i1] = bin.charCodeAt(i1);
    }
    return bytes;
}
const decode2 = decode1;
export { decode2 as decode, encode2 as encode };
var Prefix2;
(function(Prefix1) {
    Prefix1[Prefix1["Seed"] = 144] = "Seed";
    Prefix1[Prefix1["Private"] = 120] = "Private";
    Prefix1[Prefix1["Operator"] = 112] = "Operator";
    Prefix1[Prefix1["Server"] = 104] = "Server";
    Prefix1[Prefix1["Cluster"] = 16] = "Cluster";
    Prefix1[Prefix1["Account"] = 0] = "Account";
    Prefix1[Prefix1["User"] = 160] = "User";
})(Prefix2 || (Prefix2 = {
}));
class Prefixes {
    static isValidPublicPrefix(prefix) {
        return prefix == Prefix2.Server || prefix == Prefix2.Operator || prefix == Prefix2.Cluster || prefix == Prefix2.Account || prefix == Prefix2.User;
    }
    static startsWithValidPrefix(s) {
        let c = s[0];
        return c == "S" || c == "P" || c == "O" || c == "N" || c == "C" || c == "A" || c == "U";
    }
    static isValidPrefix(prefix) {
        let v = this.parsePrefix(prefix);
        return v != -1;
    }
    static parsePrefix(v) {
        switch(v){
            case Prefix2.Seed:
                return Prefix2.Seed;
            case Prefix2.Private:
                return Prefix2.Private;
            case Prefix2.Operator:
                return Prefix2.Operator;
            case Prefix2.Server:
                return Prefix2.Server;
            case Prefix2.Cluster:
                return Prefix2.Cluster;
            case Prefix2.Account:
                return Prefix2.Account;
            case Prefix2.User:
                return Prefix2.User;
            default:
                return -1;
        }
    }
}
var NKeysErrorCode2;
(function(NKeysErrorCode1) {
    NKeysErrorCode1["InvalidPrefixByte"] = "nkeys: invalid prefix byte";
    NKeysErrorCode1["InvalidKey"] = "nkeys: invalid key";
    NKeysErrorCode1["InvalidPublicKey"] = "nkeys: invalid public key";
    NKeysErrorCode1["InvalidSeedLen"] = "nkeys: invalid seed length";
    NKeysErrorCode1["InvalidSeed"] = "nkeys: invalid seed";
    NKeysErrorCode1["InvalidEncoding"] = "nkeys: invalid encoded key";
    NKeysErrorCode1["InvalidSignature"] = "nkeys: signature verification failed";
    NKeysErrorCode1["CannotSign"] = "nkeys: cannot sign, no private key available";
    NKeysErrorCode1["PublicKeyOnly"] = "nkeys: no seed or private key available";
    NKeysErrorCode1["InvalidChecksum"] = "nkeys: invalid checksum";
    NKeysErrorCode1["SerializationError"] = "nkeys: serialization error";
    NKeysErrorCode1["ApiError"] = "nkeys: api error";
    NKeysErrorCode1["ClearedPair"] = "nkeys: pair is cleared";
})(NKeysErrorCode2 || (NKeysErrorCode2 = {
}));
class NKeysError2 extends Error {
    constructor(code1, chainedError){
        super(code1);
        this.name = "NKeysError";
        this.code = code1;
        this.chainedError = chainedError;
    }
}
const Prefix1 = Prefix2;
const NKeysErrorCode1 = NKeysErrorCode2;
const NKeysError1 = NKeysError2;
const crc16tab = new Uint16Array([
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920, 
]);
class crc16 {
    static checksum(data) {
        let crc = 0;
        for(let i1 = 0; i1 < data.byteLength; i1++){
            let b = data[i1];
            crc = crc << 8 & 65535 ^ crc16tab[(crc >> 8 ^ b) & 255];
        }
        return crc;
    }
    static validate(data, expected) {
        let ba = crc16.checksum(data);
        return ba == expected;
    }
}
const b32Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
class base32 {
    static encode(src) {
        let bits = 0;
        let value = 0;
        let a = new Uint8Array(src);
        let buf = new Uint8Array(src.byteLength * 2);
        let j = 0;
        for(let i1 = 0; i1 < a.byteLength; i1++){
            value = value << 8 | a[i1];
            bits += 8;
            while(bits >= 5){
                let index = value >>> bits - 5 & 31;
                buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);
                bits -= 5;
            }
        }
        if (bits > 0) {
            let index = value << 5 - bits & 31;
            buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);
        }
        return buf.slice(0, j);
    }
    static decode(src) {
        let bits = 0;
        let byte = 0;
        let j = 0;
        let a = new Uint8Array(src);
        let out = new Uint8Array(a.byteLength * 5 / 8 | 0);
        for(let i1 = 0; i1 < a.byteLength; i1++){
            let v = String.fromCharCode(a[i1]);
            let vv = b32Alphabet.indexOf(v);
            if (vv === -1) {
                throw new Error("Illegal Base32 character: " + a[i1]);
            }
            byte = byte << 5 | vv;
            bits += 5;
            if (bits >= 8) {
                out[j++] = byte >>> bits - 8 & 255;
                bits -= 8;
            }
        }
        return out.slice(0, j);
    }
}
class Codec {
    static encode(prefix, src) {
        if (!src || !(src instanceof Uint8Array)) {
            throw new NKeysError2(NKeysErrorCode2.SerializationError);
        }
        if (!Prefixes.isValidPrefix(prefix)) {
            throw new NKeysError2(NKeysErrorCode2.InvalidPrefixByte);
        }
        return Codec._encode(false, prefix, src);
    }
    static encodeSeed(role, src) {
        if (!src) {
            throw new NKeysError2(NKeysErrorCode2.ApiError);
        }
        if (!Prefixes.isValidPublicPrefix(role)) {
            throw new NKeysError2(NKeysErrorCode2.InvalidPrefixByte);
        }
        if (src.byteLength !== 32) {
            throw new NKeysError2(NKeysErrorCode2.InvalidSeedLen);
        }
        return Codec._encode(true, role, src);
    }
    static decode(expected, src) {
        if (!Prefixes.isValidPrefix(expected)) {
            throw new NKeysError2(NKeysErrorCode2.InvalidPrefixByte);
        }
        const raw = Codec._decode(src);
        if (raw[0] !== expected) {
            throw new NKeysError2(NKeysErrorCode2.InvalidPrefixByte);
        }
        return raw.slice(1);
    }
    static decodeSeed(src) {
        const raw = Codec._decode(src);
        const prefix = Codec._decodePrefix(raw);
        if (prefix[0] != Prefix2.Seed) {
            throw new NKeysError2(NKeysErrorCode2.InvalidSeed);
        }
        if (!Prefixes.isValidPublicPrefix(prefix[1])) {
            throw new NKeysError2(NKeysErrorCode2.InvalidPrefixByte);
        }
        return {
            buf: raw.slice(2),
            prefix: prefix[1]
        };
    }
    static _encode(seed, role, payload) {
        const payloadOffset = seed ? 2 : 1;
        const payloadLen = payload.byteLength;
        const checkLen = 2;
        const cap = payloadOffset + payloadLen + 2;
        const checkOffset = payloadOffset + payloadLen;
        const raw = new Uint8Array(cap);
        if (seed) {
            const encodedPrefix = Codec._encodePrefix(Prefix2.Seed, role);
            raw.set(encodedPrefix);
        } else {
            raw[0] = role;
        }
        raw.set(payload, payloadOffset);
        const checksum = crc16.checksum(raw.slice(0, checkOffset));
        const dv = new DataView(raw.buffer);
        dv.setUint16(checkOffset, checksum, true);
        return base32.encode(raw);
    }
    static _decode(src) {
        if (src.byteLength < 4) {
            throw new NKeysError2(NKeysErrorCode2.InvalidEncoding);
        }
        let raw;
        try {
            raw = base32.decode(src);
        } catch (ex) {
            throw new NKeysError2(NKeysErrorCode2.InvalidEncoding, ex);
        }
        const checkOffset = raw.byteLength - 2;
        const dv = new DataView(raw.buffer);
        const checksum = dv.getUint16(checkOffset, true);
        const payload = raw.slice(0, checkOffset);
        if (!crc16.validate(payload, checksum)) {
            throw new NKeysError2(NKeysErrorCode2.InvalidChecksum);
        }
        return payload;
    }
    static _encodePrefix(kind, role) {
        const b1 = kind | role >> 5;
        const b2 = (role & 31) << 3;
        return new Uint8Array([
            b1,
            b2
        ]);
    }
    static _decodePrefix(raw) {
        const b1 = raw[0] & 248;
        const b2 = (raw[0] & 7) << 5 | (raw[1] & 248) >> 3;
        return new Uint8Array([
            b1,
            b2
        ]);
    }
}
class KP {
    constructor(seed){
        this.seed = seed;
    }
    getRawSeed() {
        if (!this.seed) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        let sd = Codec.decodeSeed(this.seed);
        return sd.buf;
    }
    getSeed() {
        if (!this.seed) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        return this.seed;
    }
    getPublicKey() {
        if (!this.seed) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        const sd = Codec.decodeSeed(this.seed);
        const kp = getEd25519Helper().fromSeed(this.getRawSeed());
        const buf = Codec.encode(sd.prefix, kp.publicKey);
        return new TextDecoder().decode(buf);
    }
    getPrivateKey() {
        if (!this.seed) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        const kp = getEd25519Helper().fromSeed(this.getRawSeed());
        return Codec.encode(Prefix2.Private, kp.secretKey);
    }
    sign(input) {
        if (!this.seed) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        const kp = getEd25519Helper().fromSeed(this.getRawSeed());
        return getEd25519Helper().sign(input, kp.secretKey);
    }
    verify(input, sig) {
        if (!this.seed) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        const kp = getEd25519Helper().fromSeed(this.getRawSeed());
        return getEd25519Helper().verify(input, sig, kp.publicKey);
    }
    clear() {
        if (!this.seed) {
            return;
        }
        this.seed.fill(0);
        this.seed = undefined;
    }
}
class PublicKey {
    constructor(publicKey){
        this.publicKey = publicKey;
    }
    getPublicKey() {
        if (!this.publicKey) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        return new TextDecoder().decode(this.publicKey);
    }
    getPrivateKey() {
        if (!this.publicKey) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        throw new NKeysError2(NKeysErrorCode2.PublicKeyOnly);
    }
    getSeed() {
        if (!this.publicKey) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        throw new NKeysError2(NKeysErrorCode2.PublicKeyOnly);
    }
    sign(_) {
        if (!this.publicKey) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        throw new NKeysError2(NKeysErrorCode2.CannotSign);
    }
    verify(input, sig) {
        if (!this.publicKey) {
            throw new NKeysError2(NKeysErrorCode2.ClearedPair);
        }
        let buf = Codec._decode(this.publicKey);
        return getEd25519Helper().verify(input, sig, buf.slice(1));
    }
    clear() {
        if (!this.publicKey) {
            return;
        }
        this.publicKey.fill(0);
        this.publicKey = undefined;
    }
}
function createPair2(prefix) {
    const rawSeed = getEd25519Helper().randomBytes(32);
    let str = Codec.encodeSeed(prefix, new Uint8Array(rawSeed));
    return new KP(str);
}
function createOperator2() {
    return createPair2(Prefix2.Operator);
}
function createAccount2() {
    return createPair2(Prefix2.Account);
}
function createUser2() {
    return createPair2(Prefix2.User);
}
function fromPublic2(src) {
    const ba = new TextEncoder().encode(src);
    const raw = Codec._decode(ba);
    const prefix = Prefixes.parsePrefix(raw[0]);
    if (Prefixes.isValidPublicPrefix(prefix)) {
        return new PublicKey(ba);
    }
    throw new NKeysError2(NKeysErrorCode2.InvalidPublicKey);
}
function fromSeed2(src) {
    Codec.decodeSeed(src);
    return new KP(src);
}
const createPair1 = createPair2;
const createOperator1 = createOperator2;
const createAccount1 = createAccount2;
const createUser1 = createUser2;
const fromPublic1 = fromPublic2;
const fromSeed1 = fromSeed2;
function ByteArray(n) {
    return new Uint8Array(n);
}
function HalfArray(n) {
    return new Uint16Array(n);
}
function WordArray(n) {
    return new Uint32Array(n);
}
function IntArray(n) {
    return new Int32Array(n);
}
function NumArray(n) {
    return new Float64Array(n);
}
function randomBytes(n) {
    let b = ByteArray(n);
    window.crypto.getRandomValues(b);
    return b;
}
function gf(init1) {
    const r = NumArray(16);
    if (init1) for(let i1 = 0; i1 < init1.length; i1++)r[i1] = init1[i1];
    return r;
}
const _0 = ByteArray(16);
const _9 = ByteArray(32);
_9[0] = 9;
const gf0 = gf();
const gf1 = gf([
    1
]);
const _121665 = gf([
    56129,
    1
]);
const D = gf([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
]);
const D2 = gf([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
]);
const X = gf([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
]);
const Y = gf([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
]);
const I = gf([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
]);
function A(o, a, b) {
    for(let i1 = 0; i1 < 16; i1++)o[i1] = a[i1] + b[i1];
}
function Z(o, a, b) {
    for(let i1 = 0; i1 < 16; i1++)o[i1] = a[i1] - b[i1];
}
function M(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function S(o, a) {
    M(o, a, a);
}
const _sigma = ByteArray([
    101,
    120,
    112,
    97,
    110,
    100,
    32,
    51,
    50,
    45,
    98,
    121,
    116,
    101,
    32,
    107
]);
function _stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
    const z = ByteArray(16), x = ByteArray(64);
    let u, i1;
    for(i1 = 0; i1 < 16; i1++)z[i1] = 0;
    for(i1 = 0; i1 < 8; i1++)z[i1] = n[i1];
    while(b >= 64){
        _salsa20(x, z, k, _sigma);
        for(i1 = 0; i1 < 64; i1++)c[cpos + i1] = m[mpos + i1] ^ x[i1];
        u = 1;
        for(i1 = 8; i1 < 16; i1++){
            u = u + (z[i1] & 255) | 0;
            z[i1] = u & 255;
            u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
    }
    if (b > 0) {
        _salsa20(x, z, k, _sigma);
        for(i1 = 0; i1 < b; i1++)c[cpos + i1] = m[mpos + i1] ^ x[i1];
    }
    return 0;
}
function _stream_salsa20(c, cpos, b, n, k) {
    const z = ByteArray(16), x = ByteArray(64);
    let u, i1;
    for(i1 = 0; i1 < 16; i1++)z[i1] = 0;
    for(i1 = 0; i1 < 8; i1++)z[i1] = n[i1];
    while(b >= 64){
        _salsa20(x, z, k, _sigma);
        for(i1 = 0; i1 < 64; i1++)c[cpos + i1] = x[i1];
        u = 1;
        for(i1 = 8; i1 < 16; i1++){
            u = u + (z[i1] & 255) | 0;
            z[i1] = u & 255;
            u >>>= 8;
        }
        b -= 64;
        cpos += 64;
    }
    if (b > 0) {
        _salsa20(x, z, k, _sigma);
        for(i1 = 0; i1 < b; i1++)c[cpos + i1] = x[i1];
    }
    return 0;
}
function _stream(c, cpos, d, n, k) {
    const s = ByteArray(32), sn = ByteArray(8);
    _hsalsa20(s, n, k, _sigma);
    for(let i1 = 0; i1 < 8; i1++)sn[i1] = n[i1 + 16];
    return _stream_salsa20(c, cpos, d, sn, s);
}
function _stream_xor(c, cpos, m, mpos, d, n, k) {
    const s = ByteArray(32), sn = ByteArray(8);
    _hsalsa20(s, n, k, _sigma);
    for(let i1 = 0; i1 < 8; i1++)sn[i1] = n[i1 + 16];
    return _stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
}
function poly1305_init(key) {
    const r = HalfArray(10);
    const pad = HalfArray(8);
    let t0, t1, t2, t3, t4, t5, t6, t7;
    t0 = key[0] & 255 | (key[1] & 255) << 8;
    r[0] = t0 & 8191;
    t1 = key[2] & 255 | (key[3] & 255) << 8;
    r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    t2 = key[4] & 255 | (key[5] & 255) << 8;
    r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    t3 = key[6] & 255 | (key[7] & 255) << 8;
    r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    t4 = key[8] & 255 | (key[9] & 255) << 8;
    r[4] = (t3 >>> 4 | t4 << 12) & 255;
    r[5] = t4 >>> 1 & 8190;
    t5 = key[10] & 255 | (key[11] & 255) << 8;
    r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    t6 = key[12] & 255 | (key[13] & 255) << 8;
    r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    t7 = key[14] & 255 | (key[15] & 255) << 8;
    r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    r[9] = t7 >>> 5 & 127;
    pad[0] = key[16] & 255 | (key[17] & 255) << 8;
    pad[1] = key[18] & 255 | (key[19] & 255) << 8;
    pad[2] = key[20] & 255 | (key[21] & 255) << 8;
    pad[3] = key[22] & 255 | (key[23] & 255) << 8;
    pad[4] = key[24] & 255 | (key[25] & 255) << 8;
    pad[5] = key[26] & 255 | (key[27] & 255) << 8;
    pad[6] = key[28] & 255 | (key[29] & 255) << 8;
    pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    return {
        buffer: ByteArray(16),
        r,
        h: HalfArray(10),
        pad,
        leftover: 0,
        fin: 0
    };
}
function poly1305_finish(self, mac, macpos) {
    const g = HalfArray(10);
    let c, mask, f, i1;
    const { buffer , h , pad , leftover  } = self;
    if (leftover) {
        i1 = leftover;
        buffer[i1++] = 1;
        for(; i1 < 16; i1++)buffer[i1] = 0;
        self.fin = 1;
        poly1305_blocks(self, buffer, 0, 16);
    }
    c = h[1] >>> 13;
    h[1] &= 8191;
    for(i1 = 2; i1 < 10; i1++){
        h[i1] += c;
        c = h[i1] >>> 13;
        h[i1] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for(i1 = 1; i1 < 10; i1++){
        g[i1] = h[i1] + c;
        c = g[i1] >>> 13;
        g[i1] &= 8191;
    }
    g[9] -= 1 << 13;
    mask = (c ^ 1) - 1;
    for(i1 = 0; i1 < 10; i1++)g[i1] &= mask;
    mask = ~mask;
    for(i1 = 0; i1 < 10; i1++)h[i1] = h[i1] & mask | g[i1];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    f = h[0] + pad[0];
    h[0] = f & 65535;
    for(i1 = 1; i1 < 8; i1++){
        f = (h[i1] + pad[i1] | 0) + (f >>> 16) | 0;
        h[i1] = f & 65535;
    }
    mac[macpos + 0] = h[0] >>> 0 & 255;
    mac[macpos + 1] = h[0] >>> 8 & 255;
    mac[macpos + 2] = h[1] >>> 0 & 255;
    mac[macpos + 3] = h[1] >>> 8 & 255;
    mac[macpos + 4] = h[2] >>> 0 & 255;
    mac[macpos + 5] = h[2] >>> 8 & 255;
    mac[macpos + 6] = h[3] >>> 0 & 255;
    mac[macpos + 7] = h[3] >>> 8 & 255;
    mac[macpos + 8] = h[4] >>> 0 & 255;
    mac[macpos + 9] = h[4] >>> 8 & 255;
    mac[macpos + 10] = h[5] >>> 0 & 255;
    mac[macpos + 11] = h[5] >>> 8 & 255;
    mac[macpos + 12] = h[6] >>> 0 & 255;
    mac[macpos + 13] = h[6] >>> 8 & 255;
    mac[macpos + 14] = h[7] >>> 0 & 255;
    mac[macpos + 15] = h[7] >>> 8 & 255;
}
function _onetimeauth(out, outpos, m, mpos, n, k) {
    const s = poly1305_init(k);
    poly1305_update(s, m, mpos, n);
    poly1305_finish(s, out, outpos);
    return 0;
}
function _onetimeauth_verify(h, hpos, m, mpos, n, k) {
    const x = ByteArray(16);
    _onetimeauth(x, 0, m, mpos, n, k);
    return _verify_16(h, hpos, x, 0);
}
function pack25519(o, n) {
    const m = gf(), t = gf();
    let i1, j, b;
    for(i1 = 0; i1 < 16; i1++)t[i1] = n[i1];
    car25519(t);
    car25519(t);
    car25519(t);
    for(j = 0; j < 2; j++){
        m[0] = t[0] - 65517;
        for(i1 = 1; i1 < 15; i1++){
            m[i1] = t[i1] - 65535 - (m[i1 - 1] >> 16 & 1);
            m[i1 - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
    }
    for(i1 = 0; i1 < 16; i1++){
        o[2 * i1] = t[i1] & 255;
        o[2 * i1 + 1] = t[i1] >> 8;
    }
}
function neq25519(a, b) {
    const c = ByteArray(32), d = ByteArray(32);
    pack25519(c, a);
    pack25519(d, b);
    return _verify_32(c, 0, d, 0);
}
function par25519(a) {
    const d = ByteArray(32);
    pack25519(d, a);
    return d[0] & 1;
}
function inv25519(o, i1) {
    const c = gf();
    let a;
    for(a = 0; a < 16; a++)c[a] = i1[a];
    for(a = 253; a >= 0; a--){
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i1);
    }
    for(a = 0; a < 16; a++)o[a] = c[a];
}
function _scalarMult(q, n, p) {
    const z = ByteArray(32);
    const x = NumArray(80);
    const a = gf();
    const b = gf();
    const c = gf();
    const d = gf();
    const e = gf();
    const f = gf();
    let r, i1;
    for(i1 = 0; i1 < 31; i1++)z[i1] = n[i1];
    z[31] = n[31] & 127 | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for(i1 = 0; i1 < 16; i1++){
        b[i1] = x[i1];
        d[i1] = a[i1] = c[i1] = 0;
    }
    a[0] = d[0] = 1;
    for(i1 = 254; i1 >= 0; --i1){
        r = z[i1 >>> 3] >>> (i1 & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for(i1 = 0; i1 < 16; i1++){
        x[i1 + 16] = a[i1];
        x[i1 + 32] = c[i1];
        x[i1 + 48] = b[i1];
        x[i1 + 64] = d[i1];
    }
    const x32 = x.subarray(32);
    const x16 = x.subarray(16);
    inv25519(x32, x32);
    M(x16, x16, x32);
    pack25519(q, x16);
    return 0;
}
function _scalarMult_base(q, n) {
    return _scalarMult(q, n, _9);
}
function _secretbox(c, m, d, n, k) {
    if (d < 32) return -1;
    _stream_xor(c, 0, m, 0, d, n, k);
    _onetimeauth(c, 16, c, 32, d - 32, c);
    for(let i1 = 0; i1 < 16; i1++)c[i1] = 0;
    return 0;
}
function _secretbox_open(m, c, d, n, k) {
    const x = ByteArray(32);
    if (d < 32) return -1;
    _stream(x, 0, 32, n, k);
    if (_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
    _stream_xor(m, 0, c, 0, d, n, k);
    for(let i1 = 0; i1 < 32; i1++)m[i1] = 0;
    return 0;
}
function _box_keypair(y, x) {
    x.set(randomBytes(32));
    return _scalarMult_base(y, x);
}
function _box_beforenm(k, y, x) {
    const s = ByteArray(32);
    _scalarMult(s, x, y);
    return _hsalsa20(k, _0, s, _sigma);
}
function secretbox(msg, nonce, key) {
    checkArrayTypes(msg, nonce, key);
    checkLengths(key, nonce);
    const m = ByteArray(SecretBoxLength.Zero + msg.length);
    const c = ByteArray(m.length);
    for(let i1 = 0; i1 < msg.length; i1++)m[i1 + SecretBoxLength.Zero] = msg[i1];
    _secretbox(c, m, m.length, nonce, key);
    return c.subarray(SecretBoxLength.Overhead);
}
function secretbox_open(box, nonce, key) {
    checkArrayTypes(box, nonce, key);
    checkLengths(key, nonce);
    const c = ByteArray(SecretBoxLength.Overhead + box.length);
    const m = ByteArray(c.length);
    for(let i1 = 0; i1 < box.length; i1++)c[i1 + SecretBoxLength.Overhead] = box[i1];
    if (c.length < SecretBoxLength.Zero || _secretbox_open(m, c, c.length, nonce, key) !== 0) return;
    return m.subarray(SecretBoxLength.Zero);
}
function box_before(publicKey1, secretKey) {
    checkArrayTypes(publicKey1, secretKey);
    checkBoxLengths(publicKey1, secretKey);
    const k = ByteArray(BoxLength.SharedKey);
    _box_beforenm(k, publicKey1, secretKey);
    return k;
}
function box_open(msg, nonce, publicKey1, secretKey) {
    const k = box_before(publicKey1, secretKey);
    return secretbox_open(msg, nonce, k);
}
function box_keyPair() {
    const pk = ByteArray(BoxLength.PublicKey);
    const sk = ByteArray(BoxLength.SecretKey);
    _box_keypair(pk, sk);
    return {
        publicKey: pk,
        secretKey: sk
    };
}
function box(msg, nonce, publicKey1, secretKey) {
    const k = box_before(publicKey1, secretKey);
    return secretbox(msg, nonce, k);
}
function _hashblocks_hl(hh, hl, m, n) {
    const wh = IntArray(16), wl = IntArray(16);
    let bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i1, j, h, l1, a, b, c, d;
    let ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
    let pos = 0;
    while(n >= 128){
        for(i1 = 0; i1 < 16; i1++){
            j = 8 * i1 + pos;
            wh[i1] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i1] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for(i1 = 0; i1 < 80; i1++){
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l1 = al7;
            a = l1 & 65535;
            b = l1 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l1 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l1 & 65535;
            b += l1 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l1 = al4 & al5 ^ ~al4 & al6;
            a += l1 & 65535;
            b += l1 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = _K[i1 * 2];
            l1 = _K[i1 * 2 + 1];
            a += l1 & 65535;
            b += l1 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i1 % 16];
            l1 = wl[i1 % 16];
            a += l1 & 65535;
            b += l1 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l1 = tl;
            a = l1 & 65535;
            b = l1 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l1 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l1 & 65535;
            b += l1 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l1 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l1 & 65535;
            b += l1 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l1 = bl3;
            a = l1 & 65535;
            b = l1 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l1 = tl;
            a += l1 & 65535;
            b += l1 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i1 % 16 === 15) {
                for(j = 0; j < 16; j++){
                    h = wh[j];
                    l1 = wl[j];
                    a = l1 & 65535;
                    b = l1 >>> 16;
                    c = h & 65535;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l1 = wl[(j + 9) % 16];
                    a += l1 & 65535;
                    b += l1 >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                    l1 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                    a += l1 & 65535;
                    b += l1 >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                    l1 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                    a += l1 & 65535;
                    b += l1 >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = c & 65535 | d << 16;
                    wl[j] = a & 65535 | b << 16;
                }
            }
        }
        h = ah0;
        l1 = al0;
        a = l1 & 65535;
        b = l1 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l1 = hl[0];
        a += l1 & 65535;
        b += l1 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l1 = al1;
        a = l1 & 65535;
        b = l1 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l1 = hl[1];
        a += l1 & 65535;
        b += l1 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l1 = al2;
        a = l1 & 65535;
        b = l1 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l1 = hl[2];
        a += l1 & 65535;
        b += l1 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l1 = al3;
        a = l1 & 65535;
        b = l1 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l1 = hl[3];
        a += l1 & 65535;
        b += l1 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l1 = al4;
        a = l1 & 65535;
        b = l1 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l1 = hl[4];
        a += l1 & 65535;
        b += l1 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l1 = al5;
        a = l1 & 65535;
        b = l1 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l1 = hl[5];
        a += l1 & 65535;
        b += l1 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l1 = al6;
        a = l1 & 65535;
        b = l1 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l1 = hl[6];
        a += l1 & 65535;
        b += l1 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l1 = al7;
        a = l1 & 65535;
        b = l1 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l1 = hl[7];
        a += l1 & 65535;
        b += l1 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n -= 128;
    }
    return n;
}
function pack(r, p) {
    const tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
}
const L = NumArray([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
]);
function modL(r, x) {
    let carry, i1, j, k;
    for(i1 = 63; i1 >= 32; --i1){
        carry = 0;
        for(j = i1 - 32, k = i1 - 12; j < k; ++j){
            x[j] += carry - 16 * x[i1] * L[j - (i1 - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i1] = 0;
    }
    carry = 0;
    for(j = 0; j < 32; j++){
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
    }
    for(j = 0; j < 32; j++)x[j] -= carry * L[j];
    for(i1 = 0; i1 < 32; i1++){
        x[i1 + 1] += x[i1] >> 8;
        r[i1] = x[i1] & 255;
    }
}
function add(p, q) {
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);
    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
}
function pow2523(o, i1) {
    const c = gf();
    let a;
    for(a = 0; a < 16; a++)c[a] = i1[a];
    for(a = 250; a >= 0; a--){
        S(c, c);
        if (a !== 1) M(c, c, i1);
    }
    for(a = 0; a < 16; a++)o[a] = c[a];
}
const BLAKE2S_IV = WordArray([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]);
const SIGMA = ByteArray([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
]);
const v = WordArray(16);
const m = WordArray(16);
function B2S_G(a, b, c, d, x, y) {
    v[a] = v[a] + v[b] + x;
    v[d] = ROTR32(v[d] ^ v[a], 16);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 12);
    v[a] = v[a] + v[b] + y;
    v[d] = ROTR32(v[d] ^ v[a], 8);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 7);
}
const BLAKE2B_IV32 = WordArray([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
]);
const SIGMA82 = ByteArray(SIGMA8.map((x)=>x * 2
));
const v1 = WordArray(32);
const m1 = WordArray(32);
function B2B_G(a, b, c, d, ix, iy) {
    const x0 = m1[ix];
    const x1 = m1[ix + 1];
    const y0 = m1[iy];
    const y1 = m1[iy + 1];
    ADD64AA(v1, a, b);
    ADD64AC(v1, a, x0, x1);
    let xor0 = v1[d] ^ v1[a];
    let xor1 = v1[d + 1] ^ v1[a + 1];
    v1[d] = xor1;
    v1[d + 1] = xor0;
    ADD64AA(v1, c, d);
    xor0 = v1[b] ^ v1[c];
    xor1 = v1[b + 1] ^ v1[c + 1];
    v1[b] = xor0 >>> 24 ^ xor1 << 8;
    v1[b + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v1, a, b);
    ADD64AC(v1, a, y0, y1);
    xor0 = v1[d] ^ v1[a];
    xor1 = v1[d + 1] ^ v1[a + 1];
    v1[d] = xor0 >>> 16 ^ xor1 << 16;
    v1[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v1, c, d);
    xor0 = v1[b] ^ v1[c];
    xor1 = v1[b + 1] ^ v1[c + 1];
    v1[b] = xor1 >>> 31 ^ xor0 << 1;
    v1[b + 1] = xor0 >>> 31 ^ xor1 << 1;
}
export { createAccount1 as createAccount, createOperator1 as createOperator, createPair1 as createPair, createUser1 as createUser, fromPublic1 as fromPublic, fromSeed1 as fromSeed, NKeysError1 as NKeysError, NKeysErrorCode1 as NKeysErrorCode, Prefix1 as Prefix };
function _hash(out, m2, n) {
    const hh = IntArray(8), hl = IntArray(8), x = ByteArray(256);
    let i1, b = n;
    hh[0] = 1779033703;
    hh[1] = 3144134277;
    hh[2] = 1013904242;
    hh[3] = 2773480762;
    hh[4] = 1359893119;
    hh[5] = 2600822924;
    hh[6] = 528734635;
    hh[7] = 1541459225;
    hl[0] = 4089235720;
    hl[1] = 2227873595;
    hl[2] = 4271175723;
    hl[3] = 1595750129;
    hl[4] = 2917565137;
    hl[5] = 725511199;
    hl[6] = 4215389547;
    hl[7] = 327033209;
    _hashblocks_hl(hh, hl, m2, n);
    n %= 128;
    for(i1 = 0; i1 < n; i1++)x[i1] = m2[b - n + i1];
    x[n] = 128;
    n = 256 - 128 * (n < 112 ? 1 : 0);
    x[n - 9] = 0;
    _ts64(x, n - 8, b / 536870912 | 0, b << 3);
    _hashblocks_hl(hh, hl, x, n);
    for(i1 = 0; i1 < 8; i1++)_ts64(out, 8 * i1, hh[i1], hl[i1]);
    return 0;
}
function scalarmult(p, q, s) {
    let b, i1;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for(i1 = 255; i1 >= 0; --i1){
        b = s[i1 / 8 | 0] >> (i1 & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
    }
}
function unpackneg(r, p) {
    const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r[2], gf1);
    unpack25519(r[1], p);
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);
    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);
    pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) M(r[0], r[0], I);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) return -1;
    if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
    M(r[3], r[0], r[1]);
    return 0;
}
function reduce(r) {
    const x = NumArray(64);
    let i1;
    for(i1 = 0; i1 < 64; i1++)x[i1] = r[i1];
    for(i1 = 0; i1 < 64; i1++)r[i1] = 0;
    modL(r, x);
}
function blake2s_compress(ctx, last) {
    let i1 = 0;
    for(i1 = 0; i1 < 8; i1++){
        v[i1] = ctx.h[i1];
        v[i1 + 8] = BLAKE2S_IV[i1];
    }
    v[12] ^= ctx.t;
    v[13] ^= ctx.t / 4294967296;
    if (last) {
        v[14] = ~v[14];
    }
    for(i1 = 0; i1 < 16; i1++){
        m[i1] = B2S_GET32(ctx.b, 4 * i1);
    }
    for(i1 = 0; i1 < 10; i1++){
        B2S_G(0, 4, 8, 12, m[SIGMA[i1 * 16 + 0]], m[SIGMA[i1 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m[SIGMA[i1 * 16 + 2]], m[SIGMA[i1 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m[SIGMA[i1 * 16 + 4]], m[SIGMA[i1 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m[SIGMA[i1 * 16 + 6]], m[SIGMA[i1 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m[SIGMA[i1 * 16 + 8]], m[SIGMA[i1 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m[SIGMA[i1 * 16 + 10]], m[SIGMA[i1 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m[SIGMA[i1 * 16 + 12]], m[SIGMA[i1 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m[SIGMA[i1 * 16 + 14]], m[SIGMA[i1 * 16 + 15]]);
    }
    for(i1 = 0; i1 < 8; i1++){
        ctx.h[i1] ^= v[i1] ^ v[i1 + 8];
    }
}
function blake2b_compress(ctx, last) {
    let i1;
    for(i1 = 0; i1 < 16; i1++){
        v1[i1] = ctx.h[i1];
        v1[i1 + 16] = BLAKE2B_IV32[i1];
    }
    v1[24] = v1[24] ^ ctx.t;
    v1[25] = v1[25] ^ ctx.t / 4294967296;
    if (last) {
        v1[28] = ~v1[28];
        v1[29] = ~v1[29];
    }
    for(i1 = 0; i1 < 32; i1++){
        m1[i1] = B2B_GET32(ctx.h, 4 * i1);
    }
    for(i1 = 0; i1 < 12; i1++){
        B2B_G(0, 8, 16, 24, SIGMA82[i1 * 16 + 0], SIGMA82[i1 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i1 * 16 + 2], SIGMA82[i1 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i1 * 16 + 4], SIGMA82[i1 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i1 * 16 + 6], SIGMA82[i1 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i1 * 16 + 8], SIGMA82[i1 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i1 * 16 + 10], SIGMA82[i1 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i1 * 16 + 12], SIGMA82[i1 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i1 * 16 + 14], SIGMA82[i1 * 16 + 15]);
    }
    for(i1 = 0; i1 < 16; i1++){
        ctx.h[i1] = ctx.h[i1] ^ v1[i1] ^ v1[i1 + 16];
    }
}
function hash(msg, len) {
    checkArrayTypes(msg);
    const h = ByteArray(len || HashLength.Hash);
    _hash(h, msg, msg.length);
    return h;
}
function scalarbase(p, s) {
    const q = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    M(q[3], X, Y);
    scalarmult(p, q, s);
}
function hmac(msg, key) {
    const buf = ByteArray(128 + Math.max(64, msg.length));
    let i1, innerHash;
    if (key.length > 128) key = hash(key);
    for(i1 = 0; i1 < 128; i1++)buf[i1] = 54;
    for(i1 = 0; i1 < key.length; i1++)buf[i1] ^= key[i1];
    buf.set(msg, 128);
    innerHash = hash(buf.subarray(0, 128 + msg.length));
    for(i1 = 0; i1 < 128; i1++)buf[i1] = 92;
    for(i1 = 0; i1 < key.length; i1++)buf[i1] ^= key[i1];
    buf.set(innerHash, 128);
    return hash(buf.subarray(0, 128 + innerHash.length));
}
function blake2s_update(ctx, input) {
    for(let i1 = 0; i1 < input.length; i1++){
        if (ctx.c === 64) {
            ctx.t += ctx.c;
            blake2s_compress(ctx, false);
            ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i1];
    }
}
function blake2s_final(ctx) {
    ctx.t += ctx.c;
    while(ctx.c < 64){
        ctx.b[ctx.c++] = 0;
    }
    blake2s_compress(ctx, true);
    const out = ByteArray(ctx.outlen);
    for(var i1 = 0; i1 < ctx.outlen; i1++){
        out[i1] = ctx.h[i1 >> 2] >> 8 * (i1 & 3) & 255;
    }
    return out;
}
function blake2b_update(ctx, input) {
    for(let i1 = 0; i1 < input.length; i1++){
        if (ctx.c === 128) {
            ctx.t += ctx.c;
            blake2b_compress(ctx, false);
            ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i1];
    }
}
function blake2b_final(ctx) {
    ctx.t += ctx.c;
    while(ctx.c < 128){
        ctx.b[ctx.c++] = 0;
    }
    blake2b_compress(ctx, true);
    const out = ByteArray(ctx.outlen);
    for(let i1 = 0; i1 < ctx.outlen; i1++){
        out[i1] = ctx.h[i1 >> 2] >> 8 * (i1 & 3);
    }
    return out;
}
function _sign_keypair(pk, sk, seeded) {
    const d = ByteArray(64);
    const p = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    let i1;
    if (!seeded) sk.set(randomBytes(32));
    _hash(d, sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    scalarbase(p, d);
    pack(pk, p);
    for(i1 = 0; i1 < 32; i1++)sk[i1 + 32] = pk[i1];
    return 0;
}
function _sign(sm, m2, n, sk) {
    const d = ByteArray(64), h = ByteArray(64), r = ByteArray(64);
    const x = NumArray(64);
    const p = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    let i1, j;
    _hash(d, sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    const smlen = n + 64;
    for(i1 = 0; i1 < n; i1++)sm[64 + i1] = m2[i1];
    for(i1 = 0; i1 < 32; i1++)sm[32 + i1] = d[32 + i1];
    _hash(r, sm.subarray(32), n + 32);
    reduce(r);
    scalarbase(p, r);
    pack(sm, p);
    for(i1 = 32; i1 < 64; i1++)sm[i1] = sk[i1];
    _hash(h, sm, n + 64);
    reduce(h);
    for(i1 = 0; i1 < 64; i1++)x[i1] = 0;
    for(i1 = 0; i1 < 32; i1++)x[i1] = r[i1];
    for(i1 = 0; i1 < 32; i1++){
        for(j = 0; j < 32; j++){
            x[i1 + j] += h[i1] * d[j];
        }
    }
    modL(sm.subarray(32), x);
    return smlen;
}
function _sign_open(m2, sm, n, pk) {
    const t = ByteArray(32), h = ByteArray(64);
    const p = [
        gf(),
        gf(),
        gf(),
        gf()
    ], q = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    let i1, mlen;
    mlen = -1;
    if (n < 64 || unpackneg(q, pk)) return -1;
    for(i1 = 0; i1 < n; i1++)m2[i1] = sm[i1];
    for(i1 = 0; i1 < 32; i1++)m2[i1 + 32] = pk[i1];
    _hash(h, m2, n);
    reduce(h);
    scalarmult(p, q, h);
    scalarbase(q, sm.subarray(32));
    add(p, q);
    pack(t, p);
    n -= 64;
    if (_verify_32(sm, 0, t, 0)) {
        for(i1 = 0; i1 < n; i1++)m2[i1] = 0;
        return -1;
    }
    for(i1 = 0; i1 < n; i1++)m2[i1] = sm[i1 + 64];
    mlen = n;
    return mlen;
}
function blake2s_init(outlen, key) {
    if (!(outlen > 0 && outlen <= 32)) {
        throw new Error('Incorrect output length, should be in [1, 32]');
    }
    const keylen = key ? key.length : 0;
    if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error('Incorrect key length, should be in [1, 32]');
    }
    const ctx = {
        h: WordArray(BLAKE2S_IV),
        b: WordArray(64),
        c: 0,
        t: 0,
        outlen: outlen
    };
    ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    if (keylen) {
        blake2s_update(ctx, key);
        ctx.c = 64;
    }
    return ctx;
}
function blake2b_init(outlen, key) {
    if (outlen === 0 || outlen > 64) throw new Error('Illegal output length, expected 0 < length <= 64');
    if (key && key.length > 64) throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64');
    const h = WordArray(16);
    for(let i1 = 0; i1 < 16; i1++)h[i1] = BLAKE2B_IV32[i1];
    const keylen = key ? key.length : 0;
    h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    const ctx = {
        b: ByteArray(128),
        h,
        t: 0,
        c: 0,
        outlen
    };
    if (key) {
        blake2b_update(ctx, key);
        ctx.c = 128;
    }
    return ctx;
}
function nonce_gen(pk1, pk2) {
    const state = blake2b_init(SealedBoxLength.Nonce);
    blake2b_update(state, pk1);
    blake2b_update(state, pk2);
    return blake2b_final(state);
}
function sign(msg, secretKey) {
    checkArrayTypes(msg, secretKey);
    if (secretKey.length !== SignLength.SecretKey) throw new Error('bad secret key size');
    const signedMsg = ByteArray(SignLength.Signature + msg.length);
    _sign(signedMsg, msg, msg.length, secretKey);
    return signedMsg;
}
function sign_detached(msg, secretKey) {
    const signedMsg = sign(msg, secretKey);
    const sig = ByteArray(SignLength.Signature);
    for(let i1 = 0; i1 < sig.length; i1++)sig[i1] = signedMsg[i1];
    return sig;
}
function sign_detached_verify(msg, sig, publicKey1) {
    checkArrayTypes(msg, sig, publicKey1);
    if (sig.length !== SignLength.Signature) throw new Error('bad signature size');
    if (publicKey1.length !== SignLength.PublicKey) throw new Error('bad public key size');
    const sm = ByteArray(SignLength.Signature + msg.length);
    const m2 = ByteArray(SignLength.Signature + msg.length);
    let i1;
    for(i1 = 0; i1 < SignLength.Signature; i1++)sm[i1] = sig[i1];
    for(i1 = 0; i1 < msg.length; i1++)sm[i1 + SignLength.Signature] = msg[i1];
    return _sign_open(m2, sm, sm.length, publicKey1) >= 0;
}
function sign_keyPair_fromSeed(seed1) {
    checkArrayTypes(seed1);
    if (seed1.length !== SignLength.Seed) throw new Error('bad seed size');
    const pk = ByteArray(SignLength.PublicKey);
    const sk = ByteArray(SignLength.SecretKey);
    for(let i1 = 0; i1 < 32; i1++)sk[i1] = seed1[i1];
    _sign_keypair(pk, sk, true);
    return {
        publicKey: pk,
        secretKey: sk
    };
}
const denoHelper = {
    fromSeed: sign_keyPair_fromSeed,
    sign: sign_detached,
    verify: sign_detached_verify,
    randomBytes: randomBytes
};
setEd25519Helper(denoHelper);
